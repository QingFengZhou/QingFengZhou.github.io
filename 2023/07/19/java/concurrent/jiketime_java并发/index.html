<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>jiketime_java并发 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="并发源头 synchronize 案例 解决方法1 解决方法2 解决方法3     wait-notify Usage Others wait 和 sleep 区别     管程 usage Code Test   Others   Thread 状态 调用栈 Others   并发工具类 ReentrantLock 对比synchronized Usage 特点 可重入 公平锁   Oth">
<meta property="og:type" content="article">
<meta property="og:title" content="jiketime_java并发">
<meta property="og:url" content="https://qingfengzhou.github.io/2023/07/19/java/concurrent/jiketime_java%E5%B9%B6%E5%8F%91/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="并发源头 synchronize 案例 解决方法1 解决方法2 解决方法3     wait-notify Usage Others wait 和 sleep 区别     管程 usage Code Test   Others   Thread 状态 调用栈 Others   并发工具类 ReentrantLock 对比synchronized Usage 特点 可重入 公平锁   Oth">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://qingfengzhou.github.io/2023/07/19/java/concurrent/jiketime_java%E5%B9%B6%E5%8F%91/%E6%88%AA%E5%B1%8F2023-07-19%2016.19.32.png">
<meta property="og:image" content="https://qingfengzhou.github.io/2023/07/19/java/concurrent/jiketime_java%E5%B9%B6%E5%8F%91/%E6%88%AA%E5%B1%8F2023-07-19%2016.19.40.png">
<meta property="og:image" content="https://qingfengzhou.github.io/2023/07/19/java/concurrent/jiketime_java%E5%B9%B6%E5%8F%91/%E6%88%AA%E5%B1%8F2023-07-19%2016.57.00.png">
<meta property="og:image" content="https://qingfengzhou.github.io/2023/07/19/java/concurrent/jiketime_java%E5%B9%B6%E5%8F%91/%E6%88%AA%E5%B1%8F2023-07-20%2009.10.43.png">
<meta property="og:image" content="https://qingfengzhou.github.io/2023/07/19/java/concurrent/jiketime_java%E5%B9%B6%E5%8F%91/%E6%88%AA%E5%B1%8F2023-07-20%2009.10.52.png">
<meta property="og:image" content="https://qingfengzhou.github.io/2023/07/19/java/concurrent/jiketime_java%E5%B9%B6%E5%8F%91/19_1%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202021-12-11%20%E4%B8%8B%E5%8D%8812.19.30.png">
<meta property="og:image" content="https://qingfengzhou.github.io/2023/07/19/java/concurrent/jiketime_java%E5%B9%B6%E5%8F%91/23_2%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202021-12-11%20%E4%B8%8B%E5%8D%888.31.30.png">
<meta property="article:published_time" content="2023-07-19T06:03:10.000Z">
<meta property="article:modified_time" content="2023-07-20T06:29:35.939Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://qingfengzhou.github.io/2023/07/19/java/concurrent/jiketime_java%E5%B9%B6%E5%8F%91/%E6%88%AA%E5%B1%8F2023-07-19%2016.19.32.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://qingfengzhou.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-java/concurrent/jiketime_java并发" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/07/19/java/concurrent/jiketime_java%E5%B9%B6%E5%8F%91/" class="article-date">
  <time class="dt-published" datetime="2023-07-19T06:03:10.000Z" itemprop="datePublished">2023-07-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java-concurrent/">java/concurrent</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      jiketime_java并发
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <!-- toc -->

<ul>
<li><a href="#%E5%B9%B6%E5%8F%91%E6%BA%90%E5%A4%B4">并发源头</a></li>
<li><a href="#synchronize">synchronize</a><ul>
<li><a href="#%E6%A1%88%E4%BE%8B">案例</a><ul>
<li><a href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%951">解决方法1</a></li>
<li><a href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%952">解决方法2</a></li>
<li><a href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%953">解决方法3</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#wait-notify">wait-notify</a><ul>
<li><a href="#usage">Usage</a></li>
<li><a href="#others">Others</a><ul>
<li><a href="#wait-%E5%92%8C-sleep-%E5%8C%BA%E5%88%AB">wait 和 sleep 区别</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%AE%A1%E7%A8%8B">管程</a><ul>
<li><a href="#usage">usage</a><ul>
<li><a href="#code-test">Code Test</a></li>
</ul>
</li>
<li><a href="#others-1">Others</a></li>
</ul>
</li>
<li><a href="#thread">Thread</a><ul>
<li><a href="#%E7%8A%B6%E6%80%81"><strong>状态</strong></a></li>
<li><a href="#%E8%B0%83%E7%94%A8%E6%A0%88">调用栈</a></li>
<li><a href="#others-2">Others</a></li>
</ul>
</li>
<li><a href="#%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB">并发工具类</a><ul>
<li><a href="#reentrantlock">ReentrantLock</a><ul>
<li><a href="#%E5%AF%B9%E6%AF%94synchronized"><strong>对比synchronized</strong></a></li>
<li><a href="#usage-1">Usage</a></li>
<li><a href="#%E7%89%B9%E7%82%B9">特点</a><ul>
<li><a href="#%E5%8F%AF%E9%87%8D%E5%85%A5">可重入</a></li>
<li><a href="#%E5%85%AC%E5%B9%B3%E9%94%81">公平锁</a></li>
</ul>
</li>
<li><a href="#others-3">Others</a><ul>
<li><a href="#%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5">同步和异步</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#semaphore">Semaphore</a><ul>
<li><a href="#usage-2">Usage</a><ul>
<li><a href="#%E4%BA%92%E6%96%A5%E9%94%81">互斥锁</a></li>
<li><a href="#%E9%99%90%E6%B5%81%E5%99%A8">限流器</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#reentrantreadwritelock">ReentrantReadWriteLock</a><ul>
<li><a href="#usage-3">Usage</a></li>
</ul>
</li>
<li><a href="#stampedlock">StampedLock</a><ul>
<li><a href="#%E5%86%99%E9%94%81-%E6%82%B2%E8%A7%82%E8%AF%BB%E9%94%81">写锁、悲观读锁</a></li>
<li><a href="#%E4%B9%90%E8%A7%82%E8%AF%BB">乐观读</a><ul>
<li><a href="#%E7%BB%8F%E5%85%B8%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F">经典使用方式</a></li>
</ul>
</li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a><ul>
<li><a href="#stampedlock-%E8%AF%BB%E6%A8%A1%E6%9D%BF">StampedLock 读模板</a></li>
<li><a href="#%E5%86%99%E6%A8%A1%E7%89%88">写模版</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%BA%BF%E7%A8%8B%E5%8D%8F%E8%B0%83">线程协调</a><ul>
<li><a href="#countdownlatch">CountDownLatch</a><ul>
<li><a href="#%E5%9C%BA%E6%99%AF">场景</a></li>
<li><a href="#example">Example</a></li>
</ul>
</li>
<li><a href="#cyclicbarrier">CyclicBarrier</a><ul>
<li><a href="#%E5%9C%BA%E6%99%AF-1">场景</a></li>
<li><a href="#example-1">Example</a><ul>
<li><a href="#%E4%BD%BF%E7%94%A8completablefuture-%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C">使用CompletableFuture 异步执行</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%AE%B9%E5%99%A8">容器</a><ul>
<li><a href="#%E5%90%8C%E6%AD%A5%E5%AE%B9%E5%99%A8">同步容器</a><ul>
<li><a href="#%E8%BF%AD%E4%BB%A3%E5%99%A8">迭代器</a></li>
</ul>
</li>
<li><a href="#%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8">并发容器</a><ul>
<li><a href="#copyonwritearraylist">CopyOnWriteArrayList</a><ul>
<li><a href="#%E6%B3%A8%E6%84%8F">注意</a></li>
</ul>
</li>
<li><a href="#set">Set</a></li>
<li><a href="#map">Map</a><ul>
<li><a href="#hashmap">HashMap</a></li>
<li><a href="#treemap">TreeMap</a></li>
<li><a href="#linkedhashmap">LinkedHashMap</a></li>
<li><a href="#hashtable">HashTable</a></li>
<li><a href="#concurrenthashmap">ConcurrentHashMap</a></li>
<li><a href="#concurrentskiplistmap">ConcurrentSkipListMap</a></li>
</ul>
</li>
<li><a href="#queue">Queue</a><ul>
<li><a href="#%E6%9C%89%E7%95%8C%E9%98%9F%E5%88%97">有界队列</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#cas">CAS</a><ul>
<li><a href="#usage-4">Usage</a></li>
</ul>
</li>
<li><a href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0">线程池</a><ul>
<li><a href="#%E8%B0%83%E7%94%A8">调用</a></li>
</ul>
</li>
<li><a href="#futuretask">FutureTask</a><ul>
<li><a href="#usage-5">Usage</a></li>
<li><a href="#example-2">Example</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

<h1><span id="并发源头">并发源头</span></h1><p>可见性：多核cpu缓存导致， </p>
<p>原子性：线程切换导致，解决方法：</p>
<p>有序性：编译优化导致指令重排序，</p>
<p>常见解决方法：volatile 修饰 变量，synchronized 同步，线程顺序执行</p>
<h1><span id="synchronize">synchronize</span></h1><p>修饰静态方法、非静态方法、代码快，锁定的对象不一样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class X &#123;</span><br><span class="line">  // 修饰非静态方法, 锁定的当前实例对象this</span><br><span class="line">  synchronized void foo() &#123;</span><br><span class="line">    // 临界区</span><br><span class="line">  &#125;</span><br><span class="line">  // 修饰静态方法, 锁定的是当前类的class对象, 对象例子Class X</span><br><span class="line">  synchronized static void bar() &#123;</span><br><span class="line">    // 临界区</span><br><span class="line">  &#125;</span><br><span class="line">  // 修饰代码块, 锁定一个指定的对象，对应例子 对象Obj</span><br><span class="line">  Object obj = new Object()；</span><br><span class="line">  void baz() &#123;</span><br><span class="line">    synchronized(obj) &#123;</span><br><span class="line">      // 临界区</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>



<h2><span id="案例">案例</span></h2><p>假设有 A、B、C 三个账户，余额都是 200 元，我们用两个线程分别执行两个转账操作：账户 A 转给账户 B 100 元，账户 B 转给账户 C 100 元，最后我们期望的结果应该是账户 A 的余额是 100 元，账户 B 的余额是 200 元， 账户 C 的余额是 300 元。</p>
<p>我们假设线程 1 执行账户 A 转账户 B 的操作，线程 2 执行账户 B 转账户 C 的操作。这两个线程分别在两颗 CPU 上同时执行，那它们是互斥的吗？我们期望是，但实际上并不是。因为线程 1 锁定的是账户 A 的实例（A.this），而线程 2 锁定的是账户 B 的实例（B.this），所以这两个线程可以同时进入临界区 transfer()。同时进入临界区的结果是什么呢？线程 1 和线程 2 都会读到账户 B 的余额为 200，导致最终账户 B 的余额可能是 300（线程 1 后于线程 2 写 B.balance，线程 2 写的 B.balance 值被线程 1 覆盖），可能是 100（线程 1 先于线程 2 写 B.balance，线程 1 写的 B.balance 值被线程 2 覆盖），就是不可能是 200。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">package test.zhou.java.concurrent;</span><br><span class="line"></span><br><span class="line">public class AccountTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        Account a = new Account(200);</span><br><span class="line">        Account b = new Account(200);</span><br><span class="line">        Account c = new Account(200);</span><br><span class="line">        Thread t1 = new Thread(()-&gt;&#123;</span><br><span class="line">            a.transfer(b, 100);</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread t2 = new Thread(()-&gt;&#123;</span><br><span class="line">            b.transfer(c, 100);</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(a.balance);</span><br><span class="line">        System.out.println(b.balance);</span><br><span class="line">        System.out.println(c.balance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Account &#123;</span><br><span class="line"></span><br><span class="line">    public int balance;</span><br><span class="line"></span><br><span class="line">    public Account(int balance) &#123;</span><br><span class="line">        this.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 转账</span><br><span class="line">    synchronized void transfer(</span><br><span class="line">            Account target, int amt) &#123;</span><br><span class="line">        if (this.balance &gt;= amt) &#123;</span><br><span class="line">            this.balance -= amt;</span><br><span class="line">            target.balance += amt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>账户转账结果错误，</p>
<h3><span id="解决方法1">解决方法1</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Account &#123;</span><br><span class="line">  private int balance;</span><br><span class="line">  // 转账</span><br><span class="line">  void transfer(Account target, int amt)&#123;</span><br><span class="line">    // 锁定转出账户</span><br><span class="line">    synchronized(this) &#123;              </span><br><span class="line">      // 锁定转入账户</span><br><span class="line">      synchronized(target) &#123;           </span><br><span class="line">        if (this.balance &gt; amt) &#123;</span><br><span class="line">          this.balance -= amt;</span><br><span class="line">          target.balance += amt;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="解决方法2">解决方法2</span></h3><p>方法1 可能出现死锁（一组互相竞争资源的线程因互相等待，导致“永久”阻塞的现象）</p>
<p>死锁条件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、互斥，共享资源 X 和 Y 只能被一个线程占用；</span><br><span class="line">2、占有且等待，线程 T1 已经取得共享资源 X，在等待共享资源 Y 的时候，不释放共享资源 X；</span><br><span class="line">3、不可抢占，其他线程不能强行抢占线程 T1 占有的资源；</span><br><span class="line">4、循环等待，线程 T1 等待线程 T2 占有的资源，线程 T2 等待线程 T1 占有的资源，就是循环等待。</span><br></pre></td></tr></table></figure>



<p>一次性申请所有资源：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Allocator &#123;</span><br><span class="line">  private List&lt;Object&gt; als =</span><br><span class="line">    new ArrayList&lt;&gt;();</span><br><span class="line">  // 一次性申请所有资源</span><br><span class="line">  synchronized boolean apply(</span><br><span class="line">    Object from, Object to)&#123;</span><br><span class="line">    if(als.contains(from) ||</span><br><span class="line">         als.contains(to))&#123;</span><br><span class="line">      return false;  </span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      als.add(from);</span><br><span class="line">      als.add(to);  </span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">  // 归还资源</span><br><span class="line">  synchronized void free(</span><br><span class="line">    Object from, Object to)&#123;</span><br><span class="line">    als.remove(from);</span><br><span class="line">    als.remove(to);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Account &#123;</span><br><span class="line">  // actr应该为单例</span><br><span class="line">  private Allocator actr;</span><br><span class="line">  private int balance;</span><br><span class="line">  // 转账</span><br><span class="line">  void transfer(Account target, int amt)&#123;</span><br><span class="line">    // 一次性申请转出账户和转入账户，直到成功</span><br><span class="line">    while(!actr.apply(this, target))</span><br><span class="line">      ；</span><br><span class="line">    try&#123;</span><br><span class="line">      // 锁定转出账户</span><br><span class="line">      synchronized(this)&#123;              </span><br><span class="line">        // 锁定转入账户</span><br><span class="line">        synchronized(target)&#123;           </span><br><span class="line">          if (this.balance &gt; amt)&#123;</span><br><span class="line">            this.balance -= amt;</span><br><span class="line">            target.balance += amt;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      actr.free(this, target)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="解决方法3">解决方法3</span></h3><p>方法2  执行同步方法 actr.apply(this, target)，actr是单例，多线程操作需要等待获取actr锁，仍然可能存在瓶颈。</p>
<p>方法3 是先对资源进行排序，依次加锁，效率更高。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Account &#123;</span><br><span class="line">  private int id;</span><br><span class="line">  private int balance;</span><br><span class="line">  // 转账</span><br><span class="line">  void transfer(Account target, int amt)&#123;</span><br><span class="line">    Account left = this        ①</span><br><span class="line">    Account right = target;    ②</span><br><span class="line">    if (this.id &gt; target.id) &#123; ③</span><br><span class="line">      left = target;           ④</span><br><span class="line">      right = this;            ⑤</span><br><span class="line">    &#125;                          ⑥</span><br><span class="line">    // 锁定序号小的账户</span><br><span class="line">    synchronized(left)&#123;</span><br><span class="line">      // 锁定序号大的账户</span><br><span class="line">      synchronized(right)&#123; </span><br><span class="line">        if (this.balance &gt; amt)&#123;</span><br><span class="line">          this.balance -= amt;</span><br><span class="line">          target.balance += amt;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1><span id="wait-notify">wait-notify</span></h1><p>如果线程要求的条件不满足，则线程阻塞自己，进入等待状态；当线程要求的条件满足后，通知等待的线程重新执行。</p>
<p>在 Java 语言里，等待 - 通知机制可以有多种实现方式，比如 Java 语言内置的 synchronized 配合 wait()、notify()、notifyAll() 这三个方法就能轻松实现</p>
<p>线程等待 wait 状态：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在并发程序中，当一个线程进入临界区后，由于某些条件不满足，需要进入等待状态，Java 对象的 wait() 方法就能够满足这种需求。如上图所示，当调用 wait() 方法后，当前线程就会被阻塞，并且进入到右边的等待队列中，这个等待队列也是互斥锁的等待队列。 线程在进入等待队列的同时，会释放持有的互斥锁，线程释放锁后，其他线程就有机会获得锁，并进入临界区了。</span><br></pre></td></tr></table></figure>

<p>线程通知机制：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">当条件满足时调用 notify()，会通知等待队列（互斥锁的等待队列）中的线程，告诉它条件曾经满足过。</span><br><span class="line"></span><br><span class="line">因为 notify() 只能保证在通知时间点，条件是满足的。而被通知线程的执行时间点和通知的时间点基本上不会重合，所以当线程执行的时候，很可能条件已经不满足了（保不齐有其他线程插队）。这一点你需要格外注意。</span><br><span class="line"></span><br><span class="line">除此之外，还有一个需要注意的点，被通知的线程要想重新执行，仍然需要获取到互斥锁（因为曾经获取的锁在调用 wait() 时已经释放了）</span><br><span class="line"></span><br><span class="line">wait() 和 notify() 是object 对象的方法, sleep是线程的静态方法</span><br></pre></td></tr></table></figure>

<img src="/2023/07/19/java/concurrent/jiketime_java%E5%B9%B6%E5%8F%91/截屏2023-07-19 16.19.32.png">

<img src="/2023/07/19/java/concurrent/jiketime_java%E5%B9%B6%E5%8F%91/截屏2023-07-19 16.19.40.png">





<h2><span id="usage">Usage</span></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Allocator &#123;</span><br><span class="line">  private List&lt;Object&gt; als;</span><br><span class="line">  // 一次性申请所有资源</span><br><span class="line">  synchronized void apply(</span><br><span class="line">    Object from, Object to)&#123;</span><br><span class="line">    // 经典写法</span><br><span class="line">    while(als.contains(from) ||</span><br><span class="line">         als.contains(to))&#123;</span><br><span class="line">      try&#123;</span><br><span class="line">        wait();</span><br><span class="line">      &#125;catch(Exception e)&#123;</span><br><span class="line">      &#125;   </span><br><span class="line">    &#125; </span><br><span class="line">    als.add(from);</span><br><span class="line">    als.add(to);  </span><br><span class="line">  &#125;</span><br><span class="line">  // 归还资源</span><br><span class="line">  synchronized void free(</span><br><span class="line">    Object from, Object to)&#123;</span><br><span class="line">    als.remove(from);</span><br><span class="line">    als.remove(to);</span><br><span class="line">    notifyAll();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="others">Others</span></h2><h3><span id="wait-和-sleep-区别">wait 和 sleep 区别</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1. wait会释放锁 而sleep不会释放锁资源(如果占有锁).</span><br><span class="line">2. wait只能在同步方法和同步块中使用，而sleep任何地方都可以.</span><br><span class="line">3. wait无需捕捉异常，而sleep需要.</span><br><span class="line">4. sleep是Thread的方法，而wait是Object类的方法</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1><span id="管程">管程</span></h1><p>Monitor，来自操作系统领域</p>
<p>所谓管程，指的是管理共享变量以及对共享变量的操作过程，让他们支持并发。翻译为 Java 领域的语言，就是管理类的成员变量和成员方法，让这个类是线程安全的。</p>
<p><strong>互斥 和 同步</strong></p>
<p>在并发编程领域，有两大核心问题：</p>
<p>一个是互斥，即同一时刻只允许一个线程访问共享资源；</p>
<p>另一个是同步，即线程之间如何通信、协作。</p>
<p><strong>互斥解决思路</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">管程解决互斥问题的思路很简单，就是将共享变量及其对共享变量的操作统一封装起来。</span><br><span class="line">假如我们要实现一个线程安全的阻塞队列，一个最直观的想法就是：</span><br><span class="line">将线程不安全的队列封装起来，对外提供线程安全的操作方法，例如入队操作和出队操作。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>同步解决思路：</strong></p>
<p>引入了条件变量的概念，而且每个条件变量都对应有一个等待队列</p>
<img src="/2023/07/19/java/concurrent/jiketime_java%E5%B9%B6%E5%8F%91/截屏2023-07-19 16.57.00.png">



<p>假设有个线程 T1 执行阻塞队列的出队操作，执行出队操作，需要注意有个前提条件，就是阻塞队列不能是空的（空队列只能出 Null 值，是不允许的），阻塞队列不空这个前提条件对应的就是管程里的条件变量。 如果线程 T1 进入管程后恰好发现阻塞队列是空的，那怎么办呢？等待啊，去哪里等呢？就去条件变量对应的等待队列里面等。此时线程 T1 就去“队列不空”这个条件变量的等待队列中等待。</p>
<p>再假设之后另外一个线程 T2 执行阻塞队列的入队操作，入队操作执行成功之后，“阻塞队列不空”这个条件对于线程 T1 来说已经满足了，此时线程 T2 要通知 T1，告诉它需要的条件已经满足了。当线程 T1 得到通知后，会从等待队列里面出来，但是出来之后不是马上执行，而是重新进入到入口等待队列里面。</p>
<h2><span id="usage">usage</span></h2><h3><span id="code-test">Code Test</span></h3><p>对于阻塞队列的入队操作，如果阻塞队列已满，就需要等待直到阻塞队列不满，所以这里用了notFull.await();</p>
<p>对于阻塞出队操作，如果阻塞队列为空，就需要等待直到阻塞队列不空，所以就用了notEmpty.await();</p>
<p>如果入队成功，那么阻塞队列就不空了，就需要通知条件变量：阻塞队列不空notEmpty对应的等待队列。</p>
<p>如果出队成功，那就阻塞队列就不满了，就需要通知条件变量：阻塞队列不满notFull对应的等待队列。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class BlockedQueue&lt;T&gt;&#123;</span><br><span class="line">  final Lock lock =</span><br><span class="line">    new ReentrantLock();</span><br><span class="line">  // 条件变量：队列不满  </span><br><span class="line">  final Condition notFull =</span><br><span class="line">    lock.newCondition();</span><br><span class="line">  // 条件变量：队列不空  </span><br><span class="line">  final Condition notEmpty =</span><br><span class="line">    lock.newCondition();</span><br><span class="line"></span><br><span class="line">  // 入队</span><br><span class="line">  void enq(T x) &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">      while (队列已满)&#123;</span><br><span class="line">        // 等待队列不满 </span><br><span class="line">        notFull.await();</span><br><span class="line">      &#125;  </span><br><span class="line">      // 省略入队操作...</span><br><span class="line">      //入队后,通知可出队</span><br><span class="line">      notEmpty.signal();</span><br><span class="line">    &#125;finally &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 出队</span><br><span class="line">  void deq()&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">      while (队列已空)&#123;</span><br><span class="line">        // 等待队列不空</span><br><span class="line">        notEmpty.await();</span><br><span class="line">      &#125;</span><br><span class="line">      // 省略出队操作...</span><br><span class="line">      //出队后，通知可入队</span><br><span class="line">      notFull.signal();</span><br><span class="line">    &#125;finally &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="others">Others</span></h2><p><strong>和 Java 内置的管程方案（synchronized） 对比</strong></p>
<p>Java 内置的管程方案（synchronized）使用简单，synchronized 关键字修饰的代码块，在编译期会自动生成相关加锁和解锁的代码，但是仅支持一个条件变量；而 Java SDK 并发包实现的管程支持多个条件变量，不过并发包里的锁，需要开发人员自己进行加锁和解锁操作。</p>
<h1><span id="thread">Thread</span></h1><h2><span id="状态"><strong>状态</strong></span></h2><p>1、NEW  初始化状态，刚创建未调用start方法</p>
<p>2、RUNNABLE  可执行状态，调用start 方法</p>
<p>3、Blocked  阻塞状态 </p>
<p>线程阻塞等待同步锁</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread state for a thread blocked waiting for a monitor lock.</span><br><span class="line">A thread in the blocked state is waiting for a monitor lock to enter a synchronized block/method or reenter a synchronized block/method after calling Object</span><br></pre></td></tr></table></figure>

<p>4、Waiting   无时限等待</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object.wait with no timeout</span><br><span class="line">Thread.join with no timeout  等待一个线程执行完</span><br><span class="line">LockSupport.park</span><br></pre></td></tr></table></figure>

<p>5、Timed_Waiting   有时限等待</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread.sleep</span><br><span class="line">Object.wait with timeout</span><br><span class="line">Thread.join with timeout</span><br><span class="line">LockSupport.parkNanos</span><br><span class="line">LockSupport.parkUntil</span><br></pre></td></tr></table></figure>

<p>6、Terminated  终止状态</p>
<p>thread1.interrupt()  中断一个线程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 线程处于wait状态， 调用interrupt() 方法，线程的中断状态会被清除 并且 抛出异常InterruptedException</span><br><span class="line">If this thread is blocked in an invocation of the wait(), wait(long), or wait(long, int) methods of the Object class, or of the join(), join(long), join(long, int), sleep(long), or sleep(long, int), methods of this class, then its interrupt status will be cleared and it will receive an InterruptedException.</span><br><span class="line"></span><br><span class="line">If this thread is blocked in an I/O operation upon an InterruptibleChannel then the channel will be closed, the thread&#x27;s interrupt status will be set, and the thread will receive a java.nio.channels.ClosedByInterruptException.</span><br><span class="line"></span><br><span class="line">If this thread is blocked in a java.nio.channels.Selector then the thread&#x27;s interrupt status will be set and it will return immediately from the selection operation, possibly with a non-zero value, just as if the selector&#x27;s wakeup method were invoked.</span><br></pre></td></tr></table></figure>





<p><strong>线程数量</strong></p>
<p>对于 CPU 密集型的计算场景，理论上“线程的数量 &#x3D;CPU 核数”就是最合适的。不过在工程上，线程的数量一般会设置为“CPU 核数 +1”，这样的话，当线程因为偶尔的内存页失效或其他原因导致阻塞时，这个额外的线程可以顶上，从而保证 CPU 的利用率。</p>
<p>对于 I&#x2F;O 密集型计算场景，最佳的线程数是与程序中 CPU 计算和 I&#x2F;O 操作的耗时比相关的，我们可以总结出这样一个公式：最佳线程数 &#x3D;CPU 核数 * [ 1 +（I&#x2F;O 耗时 &#x2F; CPU 耗时）]</p>
<h2><span id="调用栈">调用栈</span></h2><p>每个线程都有自己的调用栈，线程调用一次方法，产生一个栈帧，压入调用栈。每个栈帧里都有对应方法需要的参数、局部变量、返回地址。当方法返回时，对应的栈帧从调用栈弹出。</p>
<img src="/2023/07/19/java/concurrent/jiketime_java%E5%B9%B6%E5%8F%91/截屏2023-07-20 09.10.43.png">

<img src="/2023/07/19/java/concurrent/jiketime_java%E5%B9%B6%E5%8F%91/截屏2023-07-20 09.10.52.png">







<h2><span id="others">Others</span></h2><p><strong>java 进程异常和 线程栈信息</strong></p>
<p>1、Java VisualVM</p>
<p>2、jstack 使用.  </p>
<p>查看所有线程dump信息， jstack  -l   23027  &gt;&gt; &#x2F;tmp&#x2F;23027.txt</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">1.根据端口号57638查看对应进程pid/name=1463/java     </span><br><span class="line"></span><br><span class="line">   netstat -apn | grep  57638  </span><br><span class="line"></span><br><span class="line">tcp        0      0 ::ffff:172.20.5.10:57638    :::*                        LISTEN      1463/java           </span><br><span class="line">tcp        0      0 ::ffff:172.20.5.10:57638    ::ffff:172.20.5.14:59204    ESTABLISHED 1463/java</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. top 查看占用内存最多的几个进程</span><br><span class="line"></span><br><span class="line">ps aux | grep applicationName  查看对应applicationName的pid， 第二列表示pid 1463</span><br><span class="line"></span><br><span class="line">root      1463 12.5  2.3 5531468 3057636 ?     Sl   Oct12 315:22</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3. top  -p pid -H 查看进程pid对应的线程信息，这里每个线程映射对应到linux的一个进程PID</span><br><span class="line">top  -p 1463 -H</span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND                                                                                      </span><br><span class="line"> 1463 root      20   0 5401m 2.9g  39m S  0.0  2.3   0:00.00 java                                                                                          </span><br><span class="line"> 1464 root      20   0 5401m 2.9g  39m S  0.0  2.3   0:01.69 java</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4.  使用jstack查看对应线程的具体信息</span><br><span class="line">jstack pid | grep -A 10 hex(id)</span><br><span class="line">pid进程id,  -A 表示 取出对应行后，往后继续显示10行内容， </span><br><span class="line">hex(id) 表示线程PID对应的十六进制数字，全部用小写字母表示，</span><br><span class="line">可以借助计算器 或其他工具进行转换， 用python 转换： python -c &quot;print (hex(1464))&quot;</span><br><span class="line">jstack 1463 | grep -A 10 `python -c &quot;print (hex(1464))&quot;`</span><br><span class="line"></span><br><span class="line">&quot;main&quot; #1 prio=5 os_prio=0 tid=0x00007f15ac01e800 nid=0x5b8 waiting on condition [0x00007f15b0a37000]</span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (parking)</span><br><span class="line">at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">- parking to wait for  &lt;0x0000000700016ba0&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)</span><br><span class="line">at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:215)</span><br><span class="line">at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awaitNanos(AbstractQueuedSynchronizer.java:2078)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.awaitTermination(ThreadPoolExecutor.java:1465)</span><br><span class="line">at org.apache.spark.rpc.netty.Dispatcher.awaitTermination(Dispatcher.scala:180)</span><br><span class="line">at org.apache.spark.rpc.netty.NettyRpcEnv.awaitTermination(NettyRpcEnv.scala:273)</span><br><span class="line">at org.apache.spark.executor.CoarseGrainedExecutorBackend$$anonfun$run$1.apply$mcV$sp(CoarseGrainedExecutorBackend.scala:231)</span><br><span class="line">at org.apache.spark.deploy.SparkHadoopUtil$$anon$1.run(SparkHadoopUtil.scala:67)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>3、<a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/advanced-use.html#as-sh-%E5%92%8C-arthas-boot-%E6%8A%80%E5%B7%A7">Arthas</a></p>
<h1><span id="并发工具类">并发工具类</span></h1><h2><span id="reentrantlock">ReentrantLock</span></h2><p>重入锁</p>
<h3><span id="对比synchronized"><strong>对比synchronized</strong></span></h3><p>1、能够响应中断。synchronized 的问题是，持有锁 A 后，如果尝试获取锁 B 失败，那么线程就进入阻塞状态，一旦发生死锁，就没有任何机会来唤醒阻塞的线程。但如果阻塞状态的线程能够响应中断信号，也就是说当我们给阻塞的线程发送中断信号的时候，能够唤醒它，那它就有机会释放曾经持有的锁 A。这样就破坏了不可抢占条件了。</p>
<p>2、支持超时。如果线程在一段时间之内没有获取到锁，不是进入阻塞状态，而是返回一个错误，那这个线程也有机会释放曾经持有的锁。这样也能破坏不可抢占条件。</p>
<p>3、非阻塞地获取锁。如果尝试获取锁失败，并不进入阻塞状态，而是直接返回，那这个线程也有机会释放曾经持有的锁。这样也能破坏不可抢占条件。</p>
<p>对应下面三个方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 支持中断的API</span><br><span class="line">void lockInterruptibly() </span><br><span class="line">  throws InterruptedException;</span><br><span class="line">// 支持超时的API</span><br><span class="line">boolean tryLock(long time, TimeUnit unit) </span><br><span class="line">  throws InterruptedException;</span><br><span class="line">// 支持非阻塞获取锁的API</span><br><span class="line">boolean tryLock();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3><span id="usage">Usage</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class X &#123;</span><br><span class="line">  private final Lock rtl =</span><br><span class="line">  new ReentrantLock();</span><br><span class="line">  int value;</span><br><span class="line">  public void addOne() &#123;</span><br><span class="line">    // 获取锁</span><br><span class="line">    rtl.lock();  </span><br><span class="line">    try &#123;</span><br><span class="line">      value+=1;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      // 保证锁能释放</span><br><span class="line">      rtl.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="特点">特点</span></h3><h4><span id="可重入">可重入</span></h4><p>线程可以重复获取同一把锁。</p>
<p>例如下面代码中，当线程 T1 执行到 ① 处时，已经获取到了锁 rtl ，当在 ① 处调用 get() 方法时，会在 ② 再次对锁 rtl 执行加锁操作。此时，如果锁 rtl 是可重入的，那么线程 T1 可以再次加锁成功；如果锁 rtl 是不可重入的，那么线程 T1 此时会被阻塞。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class X &#123;</span><br><span class="line">  private final Lock rtl =</span><br><span class="line">  new ReentrantLock();</span><br><span class="line">  int value;</span><br><span class="line">  public int get() &#123;</span><br><span class="line">    // 获取锁</span><br><span class="line">    rtl.lock();         ②</span><br><span class="line">    try &#123;</span><br><span class="line">      return value;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      // 保证锁能释放</span><br><span class="line">      rtl.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  public void addOne() &#123;</span><br><span class="line">    // 获取锁</span><br><span class="line">    rtl.lock();  </span><br><span class="line">    try &#123;</span><br><span class="line">      value = 1 + get(); ①</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      // 保证锁能释放</span><br><span class="line">      rtl.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="公平锁">公平锁</span></h4><p>如果一个线程没有获得锁，就会进入等待队列，当有线程释放锁的时候，就需要从等待队列中唤醒一个等待的线程。如果是公平锁，唤醒的策略就是谁等待的时间长，就唤醒谁，很公平；如果是非公平锁，则不提供这个公平保证，有可能等待时间短的线程反而先被唤醒。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//无参构造函数：默认非公平锁</span><br><span class="line">public ReentrantLock() &#123;</span><br><span class="line">    sync = new NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line">//根据公平策略参数创建锁</span><br><span class="line">public ReentrantLock(boolean fair)&#123;</span><br><span class="line">    sync = fair ? new FairSync() </span><br><span class="line">                : new NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="others">Others</span></h3><h4><span id="同步和异步">同步和异步</span></h4><p>通俗点来讲就是调用方是否需要等待结果，如果需要等待结果，就是同步；如果不需要等待结果，就是异步。</p>
<p><strong>同步和异步：通常用来形容一次方法调用</strong>，针对的方法调用。同步方法调用一旦开始，调用者必须等到方法调用返回后，才能继续后面的行为；异步方法调用更像是一个消息传递，一旦开始，方法调用就会立即返回，调用者就可以继续后续的操作。再说的通俗一点，假设一段代码有两个方法：方法f1和方法f2，f1调用f2,<br>如果当f1调用f2后，f1必须等待f2完整执行完后，才能继续执行，那么这整个过程就是同步的；<br>如果当f1调用f2后, f2立即返回一个结果给f1(而实际f2内部可能并未执行完), f1收到f2返回的结果后, 继续执行后续操作，这整个过程可以认为是异步的, 和同步的区别在于 f1不需要真正等f2执行完，再去执行后续操作。  </p>
<p><strong>临界区用来表示一种公共资源或者说是共享数据，可以被多个线程使用，但是每一次</strong>，只能有一个线程使用它，一旦临界区资源被占用, 其他线程要想使用这个资源，就必须等待。<br><strong>阻塞和非阻塞 通常用来形容多线程之间的相互影响</strong>，指的是线程的状态。比如一个线程占用了临界区资源，那么所有需要这个资源的线程就必须等待，等待会导致线程挂起，这种情况就是阻塞。  </p>
<p><strong>同步阻塞io</strong> 小明去餐馆吃饭，叫了一个服务员，点了一份饭，之后小明一直在餐馆前台等待，在等待期间，小明什么事情也不能干(可能没带手机或者手机没电了，这里只是做了一个假设)，最后饭好了，服务员把饭给到小明，小明才离开餐馆。在这整个过程中，小明点餐可以看成是一个方法f1, 服务员通知后台厨房做饭可以看成是方法f2, f1调用了f2，由于f1必须等f2完整执行完才能继续执行，因此是同步的。同时, 由于f1在等待期间(出于各种各样原因被限制，只能等待)不能做别的任何事情，因此f1对应线程(调用f1的线程)是阻塞的。因此，整体来看，整个过程是同步阻塞的。  </p>
<p><strong>同步非阻塞nio</strong> 小明去餐馆吃饭，叫了一个服务员，点了一份饭，之后小明离开餐馆去做别的事情了，过了一段时间，小明回到餐馆前台询问饭是否做好了，如果饭好了，服务员把饭给到小明，小明就离开餐馆(如果饭没好，小明可以继续去干别的事情，过一段时间，再过来问一下，最后结果肯定饭会做好的)。在这整个过程中，小明点餐可以看成是一个方法f1, 服务员通知后台厨房做饭可以看成是方法f2, f1调用了f2，但是f1 不必等待 f2完整执行完才能继续执行(在这里，f1调用f2后，f2开始执行，同时f2立即返回一个结果给到f1, f1马上继续执行，基本上没有针对f2做任何等待。这里的例子可以看成是 f1调用f2后，f2执行的操作是后台厨房开始做饭，f2立即返回的结果对应的是一个票据，一个点餐号码，结果给到f1后，f1继续去做别的事情，同时f2也在继续做着自己的事情)。<strong>这里似乎好像是一个异步方法调用</strong>，其实不然，由于f1需要过一段时间，主动查询查询f2的结果(饭是否做好了)，因此仍然是同步的。同时，由于f1在等待期间可以继续去做别的事情(小明离开餐馆去做别的事情了)，因此f1对应线程(调用f1的线程)是非阻塞的，并没有处于阻塞等待的状态。因此，从整体来看，整个过程是同步非阻塞的。 <strong>相比同步阻塞，</strong>同步非阻塞其实也是一种等待，但是这里的等待并不是真的傻等下去，对应调用方线程调用完之后，可以继续执行下去，去干别的事情，过了一段时间，自己再去主动查看被调用方是否真的执行完了；而在同步阻塞中，对应调用方线程调用完之后，是一直在傻傻地等下去，也不去干别的事情，直到被调用方完整执行完， 对应调用方线程才往下继续执行。  </p>
<p><strong>异步非阻塞aio</strong> 小明去餐馆吃饭，叫了一个服务员，点了一份饭，之后小明离开餐馆去做别的事情了，过了一段时间，饭做好了，服务员通知小明(打电话或者其他各种通讯方式)来拿饭，小明获得通知后，去取饭，最后离开餐馆。和同步非阻塞nio的区别在于, 在同步非阻塞中，调用方f1仍然是主动获取到调用方f2的结果(f1过了一段时间主动查询f1), 对应例子就是 小明是自己主动去获取饭做好这条消息的(离开餐馆一段时间，自己再返回餐馆，主动询问服务员饭是否做好)，而在这里，异步非阻塞，调用方f1是被动获取到调用方f2的结果(f2完整执行完后，主动通知到f1自己的最终执行结果)，对应例子就是 小明是被动获取到饭做好这条消息的(离开餐馆一段时间后，服务员这边会给小明一个通知，饭做好了)。和同步非阻塞nio的相同点在于，对应线程(调用方法f1)都是非阻塞的，调用方对应线程 并不需要等待被调用发完全执行完，才去干别的事情。<br>平时去餐馆吃饭， 大部分情况下对应的是异步非阻塞了，当然了，其他两种情况也是有可能出现的。也有另外一种说法，<a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiexj/p/6874654.html">NIO相当于餐做好了自己去取，AIO相当于送餐上门。</a>这里其实是一致的，前者是主动拉取结果，而后者是被动获得通知，拿到结果。  </p>
<h2><span id="semaphore">Semaphore</span></h2><p>信号量模型是由 <strong>java.util.concurrent.Semaphore</strong> 实现的</p>
<p>semaphore 控制最多有多少个线程可以同时访问临界区.  acquire 和release 分别对应 down() - 和up() +</p>
<h3><span id="usage">Usage</span></h3><h4><span id="互斥锁">互斥锁</span></h4><p>作为互斥锁，保证临界区只有一个线程能够访问</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static int count;</span><br><span class="line">//初始化信号量</span><br><span class="line">static final Semaphore s </span><br><span class="line">    = new Semaphore(1);</span><br><span class="line">//用信号量保证互斥    </span><br><span class="line">static void addOne() &#123;</span><br><span class="line">  s.acquire();</span><br><span class="line">  try &#123;</span><br><span class="line">    count+=1;</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    s.release();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="限流器">限流器</span></h4><p>限制最多有count个线程同时访问临界区</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line">//控制可以同时访问的线程个数</span><br><span class="line">//https://www.cnblogs.com/dolphin0520/p/3920397.html</span><br><span class="line">public class TestSemaphore &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int N = 8;            //工人数</span><br><span class="line">        Semaphore semaphore = new Semaphore(3); //机器数目</span><br><span class="line">        for(int i=0;i&lt;N;i++)</span><br><span class="line">            new Worker(i,semaphore).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Worker extends Thread&#123;</span><br><span class="line">        private int num;</span><br><span class="line">        private Semaphore semaphore;</span><br><span class="line">        public Worker(int num,Semaphore semaphore)&#123;</span><br><span class="line">            this.num = num;</span><br><span class="line">            this.semaphore = semaphore;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                semaphore.acquire();</span><br><span class="line">                System.out.println(&quot;工人&quot;+this.num+&quot;占用一个机器在生产...&quot;);</span><br><span class="line">                Thread.sleep(2000);</span><br><span class="line">                System.out.println(&quot;工人&quot;+this.num+&quot;释放出机器&quot;);</span><br><span class="line">                semaphore.release();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="reentrantreadwritelock">ReentrantReadWriteLock</span></h2><p><strong>针对读多写少这种并发场景</strong>，Java SDK 并发包提供了读写锁——ReadWriteLock（实现类<strong>ReentrantReadWriteLock</strong>），非常容易使用，并且性能很好。</p>
<p>读写锁都遵守以下三条基本原则：</p>
<p>允许多个线程同时读共享变量；</p>
<p>只允许一个线程写共享变量；</p>
<p>如果一个写线程正在执行写操作，此时禁止读线程读共享变量。</p>
<p><strong>读写锁与互斥锁</strong>的一个重要区别就是读写锁<strong>允许多个线程同时读共享变</strong>量，而互斥锁是不允许的，这是读写锁在读多写少场景下性能优于互斥锁的关键。但读写锁的写操作是互斥的，当一个线程在写共享变量的时候，是不允许其他线程执行写操作和读操作。</p>
<h3><span id="usage">Usage</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Cache&lt;K,V&gt; &#123;</span><br><span class="line">  final Map&lt;K, V&gt; m =</span><br><span class="line">    new HashMap&lt;&gt;();</span><br><span class="line">  final ReadWriteLock rwl =</span><br><span class="line">    new ReentrantReadWriteLock();</span><br><span class="line">  // 读锁</span><br><span class="line">  final Lock r = rwl.readLock();</span><br><span class="line">  // 写锁</span><br><span class="line">  final Lock w = rwl.writeLock();</span><br><span class="line">  // 读缓存</span><br><span class="line">  V get(K key) &#123;</span><br><span class="line">    r.lock();</span><br><span class="line">    try &#123; return m.get(key); &#125;</span><br><span class="line">    finally &#123; r.unlock(); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 写缓存</span><br><span class="line">  V put(K key, V value) &#123;</span><br><span class="line">    w.lock();</span><br><span class="line">    try &#123; return m.put(key, v); &#125;</span><br><span class="line">    finally &#123; w.unlock(); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="stampedlock">StampedLock</span></h2><p>支持三种模式：写锁、悲观读锁、乐观读</p>
<h3><span id="写锁-悲观读锁">写锁、悲观读锁</span></h3><p>写锁、悲观读锁 和ReadWriteLock 功能基本一致，</p>
<p>不同的是：StampedLock 里的写锁和悲观读锁加锁成功之后，都会返回一个 stamp；然后解锁的时候，需要传入这个 stamp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">final StampedLock sl = </span><br><span class="line">  new StampedLock();</span><br><span class="line">  </span><br><span class="line">// 获取/释放悲观读锁示意代码</span><br><span class="line">long stamp = sl.readLock();</span><br><span class="line">try &#123;</span><br><span class="line">  //省略业务相关代码</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">  sl.unlockRead(stamp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取/释放写锁示意代码</span><br><span class="line">long stamp = sl.writeLock();</span><br><span class="line">try &#123;</span><br><span class="line">  //省略业务相关代码</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">  sl.unlockWrite(stamp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="乐观读">乐观读</span></h3><p>乐观读这个操作是无锁的，所以相比较 ReadWriteLock 的读锁，乐观读的性能更好一些。</p>
<p>乐观读：判断是不是有写操作正在进行，如果正在进行写，就等待写完成，或者升级为 悲观读锁</p>
<h4><span id="经典使用方式">经典使用方式</span></h4><p>乐观读 升级为悲观读锁：</p>
<p>首先通过调用 tryOptimisticRead() 获取了一个 stamp，这里的 tryOptimisticRead() 就是我们前面提到的乐观读。之后将共享变量 x 和 y 读入方法的局部变量中，不过需要注意的是，由于 tryOptimisticRead() 是无锁的，所以共享变量 x 和 y 读入方法局部变量时，x 和 y 有可能被其他线程修改了。因此最后读完之后，还需要再次验证一下是否存在写操作，这个验证操作是通过调用 validate(stamp) 来实现的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  private int x, y;</span><br><span class="line">  final StampedLock sl = </span><br><span class="line">    new StampedLock();</span><br><span class="line">  //计算到原点的距离  </span><br><span class="line">  int distanceFromOrigin() &#123;</span><br><span class="line">    // 乐观读</span><br><span class="line">    long stamp = </span><br><span class="line">      sl.tryOptimisticRead();</span><br><span class="line">    // 读入局部变量，</span><br><span class="line">    // 读的过程数据可能被修改</span><br><span class="line">    int curX = x, curY = y;</span><br><span class="line">    //判断执行读操作期间，</span><br><span class="line">    //是否存在写操作，如果存在，</span><br><span class="line">    //则sl.validate返回false</span><br><span class="line">    if (!sl.validate(stamp))&#123;</span><br><span class="line">      // 升级为悲观读锁</span><br><span class="line">      stamp = sl.readLock();</span><br><span class="line">      try &#123;</span><br><span class="line">        curX = x;</span><br><span class="line">        curY = y;</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">        //释放悲观读锁</span><br><span class="line">        sl.unlockRead(stamp);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return Math.sqrt(</span><br><span class="line">      curX * curX + curY * curY);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="总结">总结</span></h3><h4><span id="stampedlock-读模板">StampedLock 读模板</span></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">final StampedLock sl = </span><br><span class="line">  new StampedLock();</span><br><span class="line"></span><br><span class="line">// 乐观读</span><br><span class="line">long stamp = </span><br><span class="line">  sl.tryOptimisticRead();</span><br><span class="line">// 读入方法局部变量</span><br><span class="line">......</span><br><span class="line">// 校验stamp</span><br><span class="line">//是否存在写操作，如果存在，</span><br><span class="line">//则sl.validate返回false</span><br><span class="line">if (!sl.validate(stamp))&#123;</span><br><span class="line">  // 升级为悲观读锁</span><br><span class="line">  stamp = sl.readLock();</span><br><span class="line">  try &#123;</span><br><span class="line">    // 读入方法局部变量</span><br><span class="line">    .....</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    //释放悲观读锁</span><br><span class="line">    sl.unlockRead(stamp);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//使用方法局部变量执行业务操作</span><br><span class="line">......</span><br></pre></td></tr></table></figure>



<h4><span id="写模版">写模版</span></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">long stamp = sl.writeLock();</span><br><span class="line">try &#123;</span><br><span class="line">  // 写共享变量</span><br><span class="line">  ......</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">  sl.unlockWrite(stamp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="线程协调">线程协调</span></h2><h3><span id="countdownlatch">CountDownLatch</span></h3><p>倒计数器锁</p>
<h4><span id="场景">场景</span></h4><p>主要用来解决一个线程等待多个线程的场景</p>
<p>可以类比旅游团团长要等待所有的游客到齐才能去下一个景点；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* A synchronization aid that allows one or more threads to wait until</span><br><span class="line">* a set of operations being performed in other threads completes.</span><br></pre></td></tr></table></figure>



<p>一个线程要等待n个线程执行完之后，才继续执行；</p>
<p>初始化设置计数器的值为n，</p>
<p>对应执行的每个线程调用countDown()方法，计数器的值-1，</p>
<p>对应等待的线程调用await()，当计数器的值&#x3D;0，等待线程继续执行后续的代码。</p>
<p>类似生活中的例子：旅游团团长要等待所有的游客到齐才能去下一个景点</p>
<h4><span id="example">Example</span></h4><p>前几天老板突然匆匆忙忙过来，说对账系统最近越来越慢了，能不能快速优化一下。我了解了对账系统的业务后，发现还是挺简单的，用户通过在线商城下单，会生成电子订单，保存在订单库；之后物流会生成派送单给用户发货，派送单保存在派送单库。为了防止漏派送或者重复派送，对账系统每天还会校验是否存在异常订单。</p>
<p>对账系统的处理逻辑很简单，你可以参考下面的对账系统流程图。目前对账系统的处理逻辑是首先查询订单，然后查询派送单，之后对比订单和派送单，将差异写入差异库。</p>
<img src="/2023/07/19/java/concurrent/jiketime_java%E5%B9%B6%E5%8F%91/19_1屏幕快照 2021-12-11 下午12.19.30.png">



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">while(存在未对账订单)&#123;</span><br><span class="line">  // 查询未对账订单</span><br><span class="line">  pos = getPOrders();</span><br><span class="line">  // 查询派送单</span><br><span class="line">  dos = getDOrders();</span><br><span class="line">  // 执行对账操作</span><br><span class="line">  diff = check(pos, dos);</span><br><span class="line">  // 差异写入差异库</span><br><span class="line">  save(diff);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<p><strong>并行化提高性能</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">while(存在未对账订单)&#123;</span><br><span class="line">  // 查询未对账订单</span><br><span class="line">  Thread T1 = new Thread(()-&gt;&#123;</span><br><span class="line">    pos = getPOrders();</span><br><span class="line">  &#125;);</span><br><span class="line">  T1.start();</span><br><span class="line">  // 查询派送单</span><br><span class="line">  Thread T2 = new Thread(()-&gt;&#123;</span><br><span class="line">    dos = getDOrders();</span><br><span class="line">  &#125;);</span><br><span class="line">  T2.start();</span><br><span class="line">  // 等待T1、T2结束</span><br><span class="line">  T1.join();</span><br><span class="line">  T2.join();</span><br><span class="line">  // 执行对账操作</span><br><span class="line">  diff = check(pos, dos);</span><br><span class="line">  // 差异写入差异库</span><br><span class="line">  save(diff);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>





<p>while 循环里面每次都会创建新的线程，而创建线程可是个耗时的操作。所以最好是创建出来的线程能够循环利用，估计这时你已经想到线程池了，是的，线程池就能解决这个问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 创建2个线程的线程池</span><br><span class="line">Executor executor = </span><br><span class="line">  Executors.newFixedThreadPool(2);</span><br><span class="line">while(存在未对账订单)&#123;</span><br><span class="line">  // 查询未对账订单</span><br><span class="line">  executor.execute(()-&gt; &#123;</span><br><span class="line">    pos = getPOrders();</span><br><span class="line">  &#125;);</span><br><span class="line">  // 查询派送单</span><br><span class="line">  executor.execute(()-&gt; &#123;</span><br><span class="line">    dos = getDOrders();</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  /* ？？如何实现等待？？*/</span><br><span class="line">  </span><br><span class="line">  // 执行对账操作</span><br><span class="line">  diff = check(pos, dos);</span><br><span class="line">  // 差异写入差异库</span><br><span class="line">  save(diff);</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>



<p>CountDownLatch 设置主线程等待</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 创建2个线程的线程池</span><br><span class="line">Executor executor = </span><br><span class="line">  Executors.newFixedThreadPool(2);</span><br><span class="line">while(存在未对账订单)&#123;</span><br><span class="line">  // 计数器初始化为2</span><br><span class="line">  CountDownLatch latch = </span><br><span class="line">    new CountDownLatch(2);</span><br><span class="line">  // 查询未对账订单</span><br><span class="line">  executor.execute(()-&gt; &#123;</span><br><span class="line">    pos = getPOrders();</span><br><span class="line">    latch.countDown();</span><br><span class="line">  &#125;);</span><br><span class="line">  // 查询派送单</span><br><span class="line">  executor.execute(()-&gt; &#123;</span><br><span class="line">    dos = getDOrders();</span><br><span class="line">    latch.countDown();</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  // 等待两个查询操作结束</span><br><span class="line">  latch.await();</span><br><span class="line">  </span><br><span class="line">  // 执行对账操作</span><br><span class="line">  diff = check(pos, dos);</span><br><span class="line">  // 差异写入差异库</span><br><span class="line">  save(diff);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3><span id="cyclicbarrier">CyclicBarrier</span></h3><h4><span id="场景">场景</span></h4><p>是一组线程之间互相等待，更像是几个驴友之间不离不弃。</p>
<p>CyclicBarrier 的计数器是可以循环利用的，而且具备自动重置的功能，一旦计数器减到 0 会自动重置到你设置的初始值。除此之外，CyclicBarrier 还可以设置回调函数</p>
<p>循环栅栏</p>
<p>n个线程之间互相等待，每个线程调用await()方法之后，计数器值-1，进入阻塞(休眠状态)，直到最后一个线程调用await()，计数器的值为0，所有线程结束等待，之后计数器的值被重置为n；</p>
<p>此外，如何构造方法里含有回调函数，在一个 回合(如果是循环执行) 里最后执行await()的线程上 会继续执行回调函数，执行完回调函数，所有线程不再阻塞等待，之后计数器的值被重置为n；</p>
<h4><span id="example">Example</span></h4><p>CyclicBarrier 进一步并行化，实现 查询未对账订单|查询派送单  和对账操作并行化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 订单队列</span><br><span class="line">Vector&lt;P&gt; pos;</span><br><span class="line">// 派送单队列</span><br><span class="line">Vector&lt;D&gt; dos;</span><br><span class="line">// 执行回调的线程池 </span><br><span class="line">Executor executor = </span><br><span class="line">  Executors.newFixedThreadPool(1);</span><br><span class="line">  </span><br><span class="line">  //注意回调函数是异步的，不需要真实的线程执行</span><br><span class="line">final CyclicBarrier barrier =</span><br><span class="line">  new CyclicBarrier(2, ()-&gt;&#123;</span><br><span class="line">    executor.execute(()-&gt;check());</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">void check()&#123;</span><br><span class="line">  P p = pos.remove(0);</span><br><span class="line">  D d = dos.remove(0);</span><br><span class="line">  // 执行对账操作</span><br><span class="line">  diff = check(p, d);</span><br><span class="line">  // 差异写入差异库</span><br><span class="line">  save(diff);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">void checkAll()&#123;</span><br><span class="line">  // 循环查询订单库</span><br><span class="line">  Thread T1 = new Thread(()-&gt;&#123;</span><br><span class="line">    while(存在未对账订单)&#123;</span><br><span class="line">      // 查询订单库</span><br><span class="line">      pos.add(getPOrders());</span><br><span class="line">      // 等待</span><br><span class="line">      barrier.await();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  T1.start();  </span><br><span class="line">  // 循环查询运单库</span><br><span class="line">  Thread T2 = new Thread(()-&gt;&#123;</span><br><span class="line">    while(存在未对账订单)&#123;</span><br><span class="line">      // 查询运单库</span><br><span class="line">      dos.add(getDOrders());</span><br><span class="line">      // 等待</span><br><span class="line">      barrier.await();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  T2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol>
<li>回调函数使用线程池是为了异步操作，否则回掉函数是同步调用的，也就是本次对账操作执行完才能进行下一轮的检查。</li>
<li>线程数量固定为1，防止了多线程并发导致的数据不一致，因为订单和派送单是两个队列，只有单线程去两个队列中取消息才不会出现消息不匹配的问题。</li>
</ol>
<p>进一步简化：</p>
<h5><span id="使用completablefuture-异步执行">使用CompletableFuture 异步执行</span></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;List&gt; pOrderFuture = CompletableFuture.supplyAsync(this::getPOrders);</span><br><span class="line">CompletableFuture&lt;List&gt; dOrderFuture = CompletableFuture.supplyAsync(this::getDOrders);</span><br><span class="line">pOrderFuture.thenCombine(dOrderFuture, this::check)</span><br><span class="line">            .thenAccept(this::save);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2><span id="容器">容器</span></h2><h3><span id="同步容器">同步容器</span></h3><p>ArrayList、HashSet、HashMap 都不是线程安全的</p>
<p>基于synchronized 同步关键字实现，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">List list = Collections.</span><br><span class="line">  synchronizedList(new ArrayList());</span><br><span class="line">Set set = Collections.</span><br><span class="line">  synchronizedSet(new HashSet());</span><br><span class="line">Map map = Collections.</span><br><span class="line">  synchronizedMap(new HashMap());</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其他基于 synchronized 实现的容器：</p>
<p>Vector、Stack、HashTable</p>
<h4><span id="迭代器">迭代器</span></h4><p>迭代器遍历容器存在线程安全问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">List list = Collections.</span><br><span class="line">  synchronizedList(new ArrayList());</span><br><span class="line">Iterator i = list.iterator(); </span><br><span class="line">while (i.hasNext())</span><br><span class="line">  foo(i.next());</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  =》 正确的做法</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">List list = Collections.</span><br><span class="line">  synchronizedList(new ArrayList());</span><br><span class="line">synchronized (list) &#123;  </span><br><span class="line">  Iterator i = list.iterator(); </span><br><span class="line">  while (i.hasNext())</span><br><span class="line">    foo(i.next());</span><br><span class="line">&#125;    </span><br><span class="line">  </span><br></pre></td></tr></table></figure>





<p>Java 在 1.5 版本之前所谓的线程安全的容器，主要指的就是同步容器；</p>
<p>不过同步容器有个最大的问题，那就是性能差，所有方法都用 synchronized 来保证互斥，串行度太高了。因此 Java 在 1.5 及之后版本提供了性能更高的容器，我们一般称为并发容器。</p>
<h3><span id="并发容器">并发容器</span></h3><h4><span id="copyonwritearraylist">CopyOnWriteArrayList</span></h4><p>每次写入新的元素都会copy 原数组，读写可以并行，</p>
<p>遍历操作一直都是基于原 array 执行，而写操作则是基于新 array 进行。</p>
<h5><span id="注意">注意</span></h5><p>使用 CopyOnWriteArrayList 需要注意的“坑”主要有两个方面。</p>
<p>一个是应用场景，CopyOnWriteArrayList 仅适用于写操作非常少的场景，而且能够容忍读写的短暂不一致。例如上面的例子中，写入的新元素并不能立刻被遍历到。</p>
<p>另一个需要注意的是，CopyOnWriteArrayList 迭代器是只读的，不支持增删改。因为迭代器遍历的仅仅是一个快照，而对快照进行增删改是没有意义的。</p>
<h4><span id="set">Set</span></h4><p>CopyOnWriteArraySet 和 ConcurrentSkipListSet</p>
<h4><span id="map">Map</span></h4><h5><span id="hashmap">HashMap</span></h5><p>线程不安全，1.8版本的hashmap 底层基于数组 + 链表 + 红黑树 的实现方式，当相同hashcode 的key对应链表很大时，链表自动转为红黑树，相对1.7版本，性能有了一定提高；</p>
<h5><span id="treemap">TreeMap</span></h5><p>不安全，底层基于红黑树，实现了SortedMap。是一个有序map, 元素插入map时，会按照key的字典序 或者 用户定义的key 比较器Comparator 进行排序。</p>
<h5><span id="linkedhashmap">LinkedHashMap</span></h5><p>不安全，有序。 在hashmap 基础上，维护了一个双向链表， 保持插入元素的顺序性。</p>
<p>链表维护了元素插入map的顺序，也就是说，</p>
<p><strong>该map是有序的，其顺序等于元素插入map的顺序</strong>，通常可以用来实现一个LRU(Least Recently Used)缓存。</p>
<p>LRU缓存：当缓存里存放的数据个数超过规定个数后，就把最不常用的移除掉. [LRU缓存的实现](</p>
<h5><span id="hashtable">HashTable</span></h5><p>安全</p>
<p>Hashtable在hashMap基础上，每个method前面都加上了synchronized方法，因此是线程安全的，但是进行多线程读写时，所有读写操作串行化，因此性能不高；</p>
<h5><span id="concurrenthashmap">ConcurrentHashMap</span></h5><p>安全</p>
<p>1.7版本通过分段锁segment Reentrantlock，将数据划分为多个segment，每个segment对应一个Reentrantlock，这样就实现并发地读写操作；1.8版本不再使用分段锁，通过使用CAS和Synchronized同步锁，实现并发操作。</p>
<h5><span id="concurrentskiplistmap">ConcurrentSkipListMap</span></h5><p>安全</p>
<p>基于skiplist 跳表实现，</p>
<p>跳表：SkipList 本身就是一种数据结构，插入、删除、查询操作平均的时间复杂度是 O(log n)，理论上和并发线程数没有关系，所以在并发度非常高的情况下，若你对 ConcurrentHashMap 的性能还不满意，可以尝试一下 ConcurrentSkipListMap。</p>
<h4><span id="queue">Queue</span></h4><p>Java 并发包里面 Queue 这类并发容器是最复杂的，你可以从以下两个维度来分类。一个维度是阻塞与非阻塞，所谓阻塞指的是当队列已满时，入队操作阻塞；当队列已空时，出队操作阻塞。另一个维度是单端与双端，单端指的是只能队尾入队，队首出队；而双端指的是队首队尾皆可入队出队。Java 并发包里阻塞队列都用 Blocking 关键字标识，单端队列使用 Queue 标识，双端队列使用 Deque 标识。</p>
<p>单端阻塞队列: ArrayBlockingQueue、LinkedBlockingQueue</p>
<p>双端阻塞队列: LinkedBlockingDeque</p>
<p>单端非阻塞队列: ConcurrentLinkedQueue</p>
<p>双端非阻塞队列: ConcurrentLinkedDeque</p>
<h5><span id="有界队列">有界队列</span></h5><p>使用队列时，需要格外注意队列是否支持有界（所谓有界指的是内部的队列是否有容量限制）。实际工作中，一般都不建议使用无界的队列，因为数据量大了之后很容易导致 OOM。上面我们提到的这些 Queue 中，只有 ArrayBlockingQueue 和 LinkedBlockingQueue 是支持有界的，所以在使用其他无界队列时，一定要充分考虑是否存在导致 OOM 的隐患。</p>
<h2><span id="cas">CAS</span></h2><p>无锁，使用原子类</p>
<p>java.util.concurrent.atomic 包</p>
<h3><span id="usage">Usage</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">  AtomicLong count = </span><br><span class="line">    new AtomicLong(0);</span><br><span class="line">  void add10K() &#123;</span><br><span class="line">    int idx = 0;</span><br><span class="line">    while(idx++ &lt; 10000) &#123;</span><br><span class="line">      count.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="线程池">线程池</span></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ThreadPoolExecutor(</span><br><span class="line">  int corePoolSize,</span><br><span class="line">  int maximumPoolSize,</span><br><span class="line">  long keepAliveTime,</span><br><span class="line">  TimeUnit unit,</span><br><span class="line">  BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">  ThreadFactory threadFactory,</span><br><span class="line">  RejectedExecutionHandler handler) </span><br></pre></td></tr></table></figure>

<p>参数解析： 7个参数</p>
<p>corePoolSize ：核心线程池数量，表示线程池保有的最小线程数</p>
<p>maximumPoolSize： 表示线程池创建的最大线程数</p>
<p>keepAliveTime + unit:   空闲状态的线程允许存活的时间</p>
<p>workQueue：工作队列，用户提交的任务会先放置在该队列中</p>
<p>threadFactory：通过这个参数你可以自定义如何创建线程，例如可以给线程指定一个有意义的名字。</p>
<p>handler：自定义任务的拒绝策略。如果线程池中所有的线程都在忙碌，并且工作队列也满了（前提是工作队列是有界队列），那么此时提交任务，线程池就会拒绝接收。</p>
<p><strong>ThreadPoolExecutor 已经提供了以下 4 种策略</strong>：</p>
<p>CallerRunsPolicy：提交任务的线程自己去执行该任务。</p>
<p>AbortPolicy：默认的拒绝策略，会 throws RejectedExecutionException。</p>
<p>DiscardPolicy：直接丢弃任务，没有任何异常抛出。</p>
<p>DiscardOldestPolicy：丢弃最老的任务，其实就是把最早进入工作队列的任务丢弃，然后把新任务加入到工作队列。</p>
<h3><span id="调用">调用</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 无返回结果</span><br><span class="line">void execute(Runnable command) </span><br><span class="line"></span><br><span class="line">// 提交Runnable任务</span><br><span class="line">Future&lt;?&gt; </span><br><span class="line">  submit(Runnable task);</span><br><span class="line">  </span><br><span class="line">// 提交Callable任务</span><br><span class="line">&lt;T&gt; Future&lt;T&gt; </span><br><span class="line">  submit(Callable&lt;T&gt; task);</span><br><span class="line">  </span><br><span class="line">// 提交Runnable任务及结果引用  </span><br><span class="line">&lt;T&gt; Future&lt;T&gt; </span><br><span class="line">  submit(Runnable task, T result);</span><br></pre></td></tr></table></figure>

<p><strong>submit 三个方法的区别：</strong></p>
<p>1、提交 Runnable 任务 submit(Runnable task) ：这个方法的参数是一个 Runnable 接口，Runnable 接口的 run() 方法是没有返回值的，所以 submit(Runnable task) 这个方法返回的 Future 仅可以用来断言任务已经结束了，类似于 Thread.join()。</p>
<p>2、提交 Callable 任务 submit(Callable task)：这个方法的参数是一个 Callable 接口，它只有一个 call() 方法，并且这个方法是有返回值的，所以这个方法返回的 Future 对象可以通过调用其 get() 方法来获取任务的执行结果。</p>
<p>3、提交 Runnable 任务及结果引用 submit(Runnable task, T result)：这个方法很有意思，假设这个方法返回的 Future 对象是 f，f.get() 的返回值就是传给 submit() 方法的参数 result。 </p>
<p>（在实现Runnable 接口的类对应的构造函数里 传入变量T，在run方法中对变量进行操作）</p>
<p>需要你注意的是 Runnable 接口的实现类 Task 声明了一个有参构造函数 Task(Result r) ，创建 Task 对象的时候传入了 result 对象，这样就能在类 Task 的 run() 方法中对 result 进行各种操作了。result 相当于主线程和子线程之间的桥梁，通过它主子线程可以共享数据。</p>
<p>方法三使用测试：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line">import java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line">public class ThreadPoolTestReturn &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        ExecutorService executor</span><br><span class="line">                = Executors.newFixedThreadPool(1);</span><br><span class="line">// 创建Result对象r</span><br><span class="line">        Result r = new Result();</span><br><span class="line">        r.setAaa(&quot;aaa&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(r.getXxx());</span><br><span class="line"></span><br><span class="line">// 提交任务</span><br><span class="line">        Future&lt;Result&gt; future =</span><br><span class="line">                executor.submit(new Task(r), r);</span><br><span class="line">        Result fr = future.get();</span><br><span class="line"></span><br><span class="line">        System.out.println(fr.getXxx());</span><br><span class="line"></span><br><span class="line">        executor.shutdown();</span><br><span class="line"></span><br><span class="line">// 下面等式成立</span><br><span class="line">//        fr === r;</span><br><span class="line">//        fr.getAAA() === a;</span><br><span class="line">//        fr.getXXX() === x</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Task implements Runnable&#123;</span><br><span class="line">    Result r;</span><br><span class="line">    //通过构造函数传入result</span><br><span class="line">    Task(Result r)&#123;</span><br><span class="line">        this.r = r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        String a = r.getAaa();</span><br><span class="line">        r.setXxx(a);</span><br><span class="line">    &#125;</span><br><span class="line">//    public void run() &#123;</span><br><span class="line">//        //可以操作result</span><br><span class="line">//        String a = r.getAaa();</span><br><span class="line">//        r.setXxx(a);</span><br><span class="line">//    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Result &#123;</span><br><span class="line">    private String aaa;</span><br><span class="line">    private String xxx;</span><br><span class="line"></span><br><span class="line">    public void setAaa(String aaa) &#123;</span><br><span class="line">        this.aaa =aaa;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setXxx(String xxx) &#123;</span><br><span class="line">        this.xxx =xxx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getAaa() &#123;</span><br><span class="line">        return aaa;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getXxx() &#123;</span><br><span class="line">        return xxx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="futuretask">FutureTask</span></h2><h3><span id="usage">Usage</span></h3><p>FutureTask 实现了 Runnable 和 Future 接口，由于实现了 Runnable 接口，</p>
<p>所以可以将 FutureTask 对象作为任务提交给 ThreadPoolExecutor 去执行，也可以直接被 Thread 执行；</p>
<p>又因为实现了 Future 接口，所以也能用来获得任务的执行结果。</p>
<p>（1）示例代码是将 FutureTask 对象提交给 ThreadPoolExecutor 去执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 创建FutureTask</span><br><span class="line">FutureTask&lt;Integer&gt; futureTask</span><br><span class="line">  = new FutureTask&lt;&gt;(()-&gt; 1+2);</span><br><span class="line">// 创建线程池</span><br><span class="line">ExecutorService es = </span><br><span class="line">  Executors.newCachedThreadPool();</span><br><span class="line">// 提交FutureTask </span><br><span class="line">es.submit(futureTask);</span><br><span class="line">// 获取计算结果</span><br><span class="line">Integer result = futureTask.get();</span><br></pre></td></tr></table></figure>

<p>（2）FutureTask 对象直接被 Thread 执行的示例代码，利用 FutureTask 对象可以很容易获取子线程的执行结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 创建FutureTask</span><br><span class="line">FutureTask&lt;Integer&gt; futureTask</span><br><span class="line">  = new FutureTask&lt;&gt;(()-&gt; 1+2);</span><br><span class="line">// 创建并启动线程</span><br><span class="line">Thread T1 = new Thread(futureTask);</span><br><span class="line">T1.start();</span><br><span class="line">// 获取计算结果</span><br><span class="line">Integer result = futureTask.get();</span><br></pre></td></tr></table></figure>



<h3><span id="example">Example</span></h3><img src="/2023/07/19/java/concurrent/jiketime_java%E5%B9%B6%E5%8F%91/23_2屏幕快照 2021-12-11 下午8.31.30.png">



<p>我们创建了两个 FutureTask——ft1 和 ft2，ft1 完成洗水壶、烧开水、泡茶的任务，ft2 完成洗茶壶、洗茶杯、拿茶叶的任务；这里需要注意的是 ft1 这个任务在执行泡茶任务前，需要等待 ft2 把茶叶拿来，所以 ft1 内部需要引用 ft2，并在执行泡茶之前，调用 ft2 的 get() 方法实现等待。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 创建任务T2的FutureTask</span><br><span class="line">FutureTask&lt;String&gt; ft2</span><br><span class="line">  = new FutureTask&lt;&gt;(new T2Task());</span><br><span class="line">// 创建任务T1的FutureTask</span><br><span class="line">FutureTask&lt;String&gt; ft1</span><br><span class="line">  = new FutureTask&lt;&gt;(new T1Task(ft2));</span><br><span class="line">// 线程T1执行任务ft1</span><br><span class="line">Thread T1 = new Thread(ft1);</span><br><span class="line">T1.start();</span><br><span class="line">// 线程T2执行任务ft2</span><br><span class="line">Thread T2 = new Thread(ft2);</span><br><span class="line">T2.start();</span><br><span class="line">// 等待线程T1执行结果</span><br><span class="line">System.out.println(ft1.get());</span><br><span class="line"></span><br><span class="line">// T1Task需要执行的任务：</span><br><span class="line">// 洗水壶、烧开水、泡茶</span><br><span class="line">class T1Task implements Callable&lt;String&gt;&#123;</span><br><span class="line">  FutureTask&lt;String&gt; ft2;</span><br><span class="line">  // T1任务需要T2任务的FutureTask</span><br><span class="line">  T1Task(FutureTask&lt;String&gt; ft2)&#123;</span><br><span class="line">    this.ft2 = ft2;</span><br><span class="line">  &#125;</span><br><span class="line">  @Override</span><br><span class="line">  String call() throws Exception &#123;</span><br><span class="line">    System.out.println(&quot;T1:洗水壶...&quot;);</span><br><span class="line">    TimeUnit.SECONDS.sleep(1);</span><br><span class="line">    </span><br><span class="line">    System.out.println(&quot;T1:烧开水...&quot;);</span><br><span class="line">    TimeUnit.SECONDS.sleep(15);</span><br><span class="line">    // 获取T2线程的茶叶  </span><br><span class="line">    String tf = ft2.get();</span><br><span class="line">    System.out.println(&quot;T1:拿到茶叶:&quot;+tf);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;T1:泡茶...&quot;);</span><br><span class="line">    return &quot;上茶:&quot; + tf;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// T2Task需要执行的任务:</span><br><span class="line">// 洗茶壶、洗茶杯、拿茶叶</span><br><span class="line">class T2Task implements Callable&lt;String&gt; &#123;</span><br><span class="line">  @Override</span><br><span class="line">  String call() throws Exception &#123;</span><br><span class="line">    System.out.println(&quot;T2:洗茶壶...&quot;);</span><br><span class="line">    TimeUnit.SECONDS.sleep(1);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;T2:洗茶杯...&quot;);</span><br><span class="line">    TimeUnit.SECONDS.sleep(2);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;T2:拿茶叶...&quot;);</span><br><span class="line">    TimeUnit.SECONDS.sleep(1);</span><br><span class="line">    return &quot;龙井&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 一次执行结果：</span><br><span class="line">T1:洗水壶...</span><br><span class="line">T2:洗茶壶...</span><br><span class="line">T1:烧开水...</span><br><span class="line">T2:洗茶杯...</span><br><span class="line">T2:拿茶叶...</span><br><span class="line">T1:拿到茶叶:龙井</span><br><span class="line">T1:泡茶...</span><br><span class="line">上茶:龙井</span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://qingfengzhou.github.io/2023/07/19/java/concurrent/jiketime_java%E5%B9%B6%E5%8F%91/" data-id="clkag9wyn00004v9a2apq02d6" data-title="jiketime_java并发" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2023/07/17/bigdata/sql/doc_sql/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">doc_sql</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/bigdata-flink-flink-doc/">bigdata/flink/flink_doc</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/bigdata-hadoop-hadoop-env/">bigdata/hadoop/hadoop_env</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/bigdata-nosql-hbase/">bigdata/nosql/hbase</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/bigdata-spark/">bigdata/spark</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/bigdata-spark-spark3/">bigdata/spark/spark3</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/bigdata-spark-spark-env/">bigdata/spark/spark_env</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/bigdata-spark-sparksql-kyuubi/">bigdata/spark/sparksql/kyuubi</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/bigdata-sql/">bigdata/sql</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java-concurrent/">java/concurrent</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/life-daily/">life/daily</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/life-thought/">life/thought</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/system-linux-ansible/">system/linux/ansible</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/system-linux-command/">system/linux/command</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/system-linux-host-monitor/">system/linux/host/monitor</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/system-linux-prometheus/">system/linux/prometheus</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/tools-draw-%E5%9C%A8%E7%BA%BF%E7%94%BB%E5%9B%BE/">tools/draw/在线画图</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/tools-github-hexo/">tools/github/hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/tools-java-maven/">tools/java/maven</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/flink/" rel="tag">flink</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hadoop/" rel="tag">hadoop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spark/" rel="tag">spark</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sql/" rel="tag">sql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tools/" rel="tag">tools</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/flink/" style="font-size: 10px;">flink</a> <a href="/tags/hadoop/" style="font-size: 10px;">hadoop</a> <a href="/tags/java/" style="font-size: 10px;">java</a> <a href="/tags/spark/" style="font-size: 20px;">spark</a> <a href="/tags/sql/" style="font-size: 10px;">sql</a> <a href="/tags/tools/" style="font-size: 10px;">tools</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">July 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/06/">June 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/07/19/java/concurrent/jiketime_java%E5%B9%B6%E5%8F%91/">jiketime_java并发</a>
          </li>
        
          <li>
            <a href="/2023/07/17/bigdata/sql/doc_sql/">doc_sql</a>
          </li>
        
          <li>
            <a href="/2023/07/13/bigdata/flink/flink_doc/flink_sql_20230713/">flink_sql_20230713</a>
          </li>
        
          <li>
            <a href="/2023/07/13/bigdata/spark/spark_env/spark_terminal_tips/">spark_terminal_tips</a>
          </li>
        
          <li>
            <a href="/2023/07/13/bigdata/spark/spark3/20230712_spark_delta_lake/">20230713_delta_lake</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>